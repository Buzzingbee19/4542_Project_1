Knapsack

The Knapsack problem revealed itself to us as a form of a yes-no problem; an item was either included or not in the final knapsack. To truly call our algorithm exhaustive we had to test all possible combinations of all possible items in the most rudimentary manner. To do this we created an array representing a binary number, only including the items with a one as it slowly counted through all the combinations. At every step the code compares the current combination to the best one its found so far. Itâ€™s quickly seen that the run time grows in a 2^n manner. This falls into an issue later when runtime starts to cut off the later combinations. When we get to the larger files, our program started to break the 10-minute bound at the 48 mark, a bias towards the front of the items is apparent as the program progresses through the items from the beginning and slows down towards later combinations. At the largest files, it stops reaching the first items entirely, this is because our binary string starts at the most significant bit. Also, we see that the cost limit is so large that the correct knapsack it produces is just a list of the beginning variables, as it takes so long to go through all their combinations that it never gets close to the max. As a heuristic, this algorithm is best for small instances. 
